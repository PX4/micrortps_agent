// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file vtol_vehicle_status.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "vtol_vehicle_status.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>






vtol_vehicle_status::vtol_vehicle_status()
{
    // m_timestamp_ com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5ae63ade
    m_timestamp_ = 0;
    // m_vtol_in_rw_mode_ com.eprosima.idl.parser.typecode.PrimitiveTypeCode@610694f1
    m_vtol_in_rw_mode_ = false;
    // m_vtol_in_trans_mode_ com.eprosima.idl.parser.typecode.PrimitiveTypeCode@43814d18
    m_vtol_in_trans_mode_ = false;
    // m_in_transition_to_fw_ com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5c5a1b69
    m_in_transition_to_fw_ = false;
    // m_vtol_transition_failsafe_ com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3701eaf6
    m_vtol_transition_failsafe_ = false;
    // m_fw_permanent_stab_ com.eprosima.idl.parser.typecode.PrimitiveTypeCode@627551fb
    m_fw_permanent_stab_ = false;

}

vtol_vehicle_status::~vtol_vehicle_status()
{






}

vtol_vehicle_status::vtol_vehicle_status(const vtol_vehicle_status &x)
{
    m_timestamp_ = x.m_timestamp_;
    m_vtol_in_rw_mode_ = x.m_vtol_in_rw_mode_;
    m_vtol_in_trans_mode_ = x.m_vtol_in_trans_mode_;
    m_in_transition_to_fw_ = x.m_in_transition_to_fw_;
    m_vtol_transition_failsafe_ = x.m_vtol_transition_failsafe_;
    m_fw_permanent_stab_ = x.m_fw_permanent_stab_;
}

vtol_vehicle_status::vtol_vehicle_status(vtol_vehicle_status &&x)
{
    m_timestamp_ = x.m_timestamp_;
    m_vtol_in_rw_mode_ = x.m_vtol_in_rw_mode_;
    m_vtol_in_trans_mode_ = x.m_vtol_in_trans_mode_;
    m_in_transition_to_fw_ = x.m_in_transition_to_fw_;
    m_vtol_transition_failsafe_ = x.m_vtol_transition_failsafe_;
    m_fw_permanent_stab_ = x.m_fw_permanent_stab_;
}

vtol_vehicle_status& vtol_vehicle_status::operator=(const vtol_vehicle_status &x)
{

    m_timestamp_ = x.m_timestamp_;
    m_vtol_in_rw_mode_ = x.m_vtol_in_rw_mode_;
    m_vtol_in_trans_mode_ = x.m_vtol_in_trans_mode_;
    m_in_transition_to_fw_ = x.m_in_transition_to_fw_;
    m_vtol_transition_failsafe_ = x.m_vtol_transition_failsafe_;
    m_fw_permanent_stab_ = x.m_fw_permanent_stab_;

    return *this;
}

vtol_vehicle_status& vtol_vehicle_status::operator=(vtol_vehicle_status &&x)
{

    m_timestamp_ = x.m_timestamp_;
    m_vtol_in_rw_mode_ = x.m_vtol_in_rw_mode_;
    m_vtol_in_trans_mode_ = x.m_vtol_in_trans_mode_;
    m_in_transition_to_fw_ = x.m_in_transition_to_fw_;
    m_vtol_transition_failsafe_ = x.m_vtol_transition_failsafe_;
    m_fw_permanent_stab_ = x.m_fw_permanent_stab_;

    return *this;
}

size_t vtol_vehicle_status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t vtol_vehicle_status::getCdrSerializedSize(const vtol_vehicle_status& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void vtol_vehicle_status::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_timestamp_;
    scdr << m_vtol_in_rw_mode_;
    scdr << m_vtol_in_trans_mode_;
    scdr << m_in_transition_to_fw_;
    scdr << m_vtol_transition_failsafe_;
    scdr << m_fw_permanent_stab_;
}

void vtol_vehicle_status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_timestamp_;
    dcdr >> m_vtol_in_rw_mode_;
    dcdr >> m_vtol_in_trans_mode_;
    dcdr >> m_in_transition_to_fw_;
    dcdr >> m_vtol_transition_failsafe_;
    dcdr >> m_fw_permanent_stab_;
}

/*!
 * @brief This function sets a value in member timestamp_
 * @param _timestamp_ New value for member timestamp_
 */
void vtol_vehicle_status::timestamp_(uint64_t _timestamp_)
{
m_timestamp_ = _timestamp_;
}

/*!
 * @brief This function returns the value of member timestamp_
 * @return Value of member timestamp_
 */
uint64_t vtol_vehicle_status::timestamp_() const
{
    return m_timestamp_;
}

/*!
 * @brief This function returns a reference to member timestamp_
 * @return Reference to member timestamp_
 */
uint64_t& vtol_vehicle_status::timestamp_()
{
    return m_timestamp_;
}

/*!
 * @brief This function sets a value in member vtol_in_rw_mode_
 * @param _vtol_in_rw_mode_ New value for member vtol_in_rw_mode_
 */
void vtol_vehicle_status::vtol_in_rw_mode_(bool _vtol_in_rw_mode_)
{
m_vtol_in_rw_mode_ = _vtol_in_rw_mode_;
}

/*!
 * @brief This function returns the value of member vtol_in_rw_mode_
 * @return Value of member vtol_in_rw_mode_
 */
bool vtol_vehicle_status::vtol_in_rw_mode_() const
{
    return m_vtol_in_rw_mode_;
}

/*!
 * @brief This function returns a reference to member vtol_in_rw_mode_
 * @return Reference to member vtol_in_rw_mode_
 */
bool& vtol_vehicle_status::vtol_in_rw_mode_()
{
    return m_vtol_in_rw_mode_;
}

/*!
 * @brief This function sets a value in member vtol_in_trans_mode_
 * @param _vtol_in_trans_mode_ New value for member vtol_in_trans_mode_
 */
void vtol_vehicle_status::vtol_in_trans_mode_(bool _vtol_in_trans_mode_)
{
m_vtol_in_trans_mode_ = _vtol_in_trans_mode_;
}

/*!
 * @brief This function returns the value of member vtol_in_trans_mode_
 * @return Value of member vtol_in_trans_mode_
 */
bool vtol_vehicle_status::vtol_in_trans_mode_() const
{
    return m_vtol_in_trans_mode_;
}

/*!
 * @brief This function returns a reference to member vtol_in_trans_mode_
 * @return Reference to member vtol_in_trans_mode_
 */
bool& vtol_vehicle_status::vtol_in_trans_mode_()
{
    return m_vtol_in_trans_mode_;
}

/*!
 * @brief This function sets a value in member in_transition_to_fw_
 * @param _in_transition_to_fw_ New value for member in_transition_to_fw_
 */
void vtol_vehicle_status::in_transition_to_fw_(bool _in_transition_to_fw_)
{
m_in_transition_to_fw_ = _in_transition_to_fw_;
}

/*!
 * @brief This function returns the value of member in_transition_to_fw_
 * @return Value of member in_transition_to_fw_
 */
bool vtol_vehicle_status::in_transition_to_fw_() const
{
    return m_in_transition_to_fw_;
}

/*!
 * @brief This function returns a reference to member in_transition_to_fw_
 * @return Reference to member in_transition_to_fw_
 */
bool& vtol_vehicle_status::in_transition_to_fw_()
{
    return m_in_transition_to_fw_;
}

/*!
 * @brief This function sets a value in member vtol_transition_failsafe_
 * @param _vtol_transition_failsafe_ New value for member vtol_transition_failsafe_
 */
void vtol_vehicle_status::vtol_transition_failsafe_(bool _vtol_transition_failsafe_)
{
m_vtol_transition_failsafe_ = _vtol_transition_failsafe_;
}

/*!
 * @brief This function returns the value of member vtol_transition_failsafe_
 * @return Value of member vtol_transition_failsafe_
 */
bool vtol_vehicle_status::vtol_transition_failsafe_() const
{
    return m_vtol_transition_failsafe_;
}

/*!
 * @brief This function returns a reference to member vtol_transition_failsafe_
 * @return Reference to member vtol_transition_failsafe_
 */
bool& vtol_vehicle_status::vtol_transition_failsafe_()
{
    return m_vtol_transition_failsafe_;
}

/*!
 * @brief This function sets a value in member fw_permanent_stab_
 * @param _fw_permanent_stab_ New value for member fw_permanent_stab_
 */
void vtol_vehicle_status::fw_permanent_stab_(bool _fw_permanent_stab_)
{
m_fw_permanent_stab_ = _fw_permanent_stab_;
}

/*!
 * @brief This function returns the value of member fw_permanent_stab_
 * @return Value of member fw_permanent_stab_
 */
bool vtol_vehicle_status::fw_permanent_stab_() const
{
    return m_fw_permanent_stab_;
}

/*!
 * @brief This function returns a reference to member fw_permanent_stab_
 * @return Reference to member fw_permanent_stab_
 */
bool& vtol_vehicle_status::fw_permanent_stab_()
{
    return m_fw_permanent_stab_;
}


size_t vtol_vehicle_status::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;









    return current_align;
}

bool vtol_vehicle_status::isKeyDefined()
{
   return false;
}

void vtol_vehicle_status::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
     
     
     
     
}
